;;**********************************************************************
;; ROM monitor for DIY 6809 computer
;;**********************************************************************

	INCLUDE "../Include/iodev.asm"

;;**********************************************************************
;; Constants
;;**********************************************************************

;; Character values
CR EQU $0D
NL EQU $0A
SPACE EQU $20
TAB EQU $09
COLON EQU $3A

;; 3.6864 MHz crystal: E clock is 921.6 kHz, divide by 96 to get 9600 bps
ACIA_CLKDIV EQU 6

;; Compute initial value for ACIA control register
;; Note that even though the rx/tx clock is generated by
;; the 82C54 counter/timer, the ACIA /16 divisor is used,
;; because with the /1 divisor, there is no automatic
;; synchronization of the rx/tx data and clocks.
ACIA_INIT EQU (ACIA_CTRL_CLKDIV_16 | ACIA_CTRL_SEL_8N1 | ACIA_CTRL_XMIT_RTS_LOW_TX_INT_DIS | ACIA_CTRL_RX_INT_DIS)

;; Number of characters that can be stored in the command buffer
;; (actual buffer is 1 larger to allow room for the nul terminator.)
;; This size is chosen to allow ihex records with 32 data bytes to
;; be read (these will be 75 bytes).
MONTIOR_MAXCMDLEN equ 99

;; Intel hex record types.
IHEX_DATA EQU 0
IHEX_EOF EQU 1
IHEX_ERROR EQU 99

;; Clearing bit 4 of the condition code register enables
;; regular (IRQ) interrupts.
ENABLE_IRQ EQU 0b11101111

;; Setting bit 4 of the condition code register disables
;; regular (IRQ) interrupts.
DISABLE_IRQ EQU 0b00010000

;; Special values which can be written to the i82c55a control port
;; in order to set and clear bits 0 and 1, which drive the -SET
;; inputs used for detecting edge-triggered interrupts.
;; (When a byte where the high bit is 0 is written to the control port,
;; it sets or resets a single bit in port C. See 82C55A datasheet.)
IRQ3_FF_SET_ASSERT    EQU 0b00000000
IRQ3_FF_SET_DEASSERT  EQU 0b00000001
IRQ6_FF_SET_ASSERT    EQU 0b00000010
IRQ6_FF_SET_DEASSERT  EQU 0b00000011

;; HWVGA stuff
HWVGA_DEFAULT_ATTR    EQU (HWVGA_BG_BLACK|HWVGA_FG_BR_CYAN)

;;**********************************************************************
;; Variables (RAM area)
;;
;; Since the goal is to generate a ROM image, this
;; part is discarded.  It's very useful, however, to have
;; the assembler determine the addresses of variables
;; and determine the overall amount of memory needed for
;; them.
;;**********************************************************************

	ORG $0000

	INCLUDE "monvars.asm"
	INCLUDE "hwvgavars.asm"

;;**********************************************************************
;; Code
;;
;; Everything from $8000 onward is part of the ROM image.
;;**********************************************************************

	;; The first 4K of the upper 32K is not used because it
	;; is reserved for I/O devices.
	ORG $8000
	FILL $FF, 4096

	;; The actual code begins at $9000
	ORG $9000

entry
	;; put system stack at top of RAM
	lds #$7FFE

	;; Initialize the i82c55a device
	jsr i82c55a_init

	;; Initialize the i82c54 device
	jsr i82c54_init

	;; Initialize the ACIA
	jsr acia_init

	;; Initialize the interrupt controller and IRQ handling
	jsr irqctrl_init

	;; Initialize keyboard handling
	jsr kbd_init

;	; Initialize TMS9918A VDP
;	jsr tms9918a_init

	; Initialize hardware VGA text display
	jsr hwvga_init

	;; Initialize monitor I/O routines
	jsr mon_init

	;; Welcome message
	ldx #ALL_YOUR_BASE
	jsr acia_send_string

	; Set initial monitor address to 0
	ldd #0
	std vmonaddr

main_loop
	; Print current address as part of prompt
	ldd vmonaddr
	jsr mon_print_hex_d
	ldx #MONITOR_PROMPT
	jsr acia_send_string

	jsr mon_read_command          ; read user command
	jsr mon_exec_command          ; attempt to execute the command

	jmp main_loop                 ; repeat main loop

;;------------------------------------------------------------------
;; Monitor routines
;;------------------------------------------------------------------

	INCLUDE "monfns.asm"

;;------------------------------------------------------------------
;; Monitor command routines
;;
;; For all monitor command handler routines, the X register
;; is set to point to the first character of the argument
;; to the command.  For example, if the command was
;;
;;    w cafe
;;
;; then X will be pointing to the 'c' character.
;;------------------------------------------------------------------

;; Question command: prints an identification string
mon_ques_cmd
	ldx #MONITOR_IDENT_MSG
	jsr acia_send_string
	rts

;; 'e' (echo) command: just prints back the portion of the command
;; following the command character
mon_e_cmd
	jsr acia_send_string
	ldx #CRLF
	jsr acia_send_string
	rts

;; Command handler for 'a' (set address) command.
mon_a_cmd
	jsr mon_parse_hex_d
	std vmonaddr
	rts

;; Command handler for 'r' (read) command.
;; Parses two hex digits and prints out the hex representation
;; of that many values from memory at the current address.
;; Updates the current address by the number of bytes read.
mon_r_cmd
	jsr mon_parse_hex             ; get number of bytes to read
	tfr A, B                      ; put # bytes to read in B
	ldx vmonaddr                  ; put current monitor addr in X

	; loop to print bytes
10
	cmpb #0                       ; more bytes to read?
	beq 99f                       ; if not, we're done

	pshs B, X                     ; save B and X
	lda ,X                        ; get next byte
	jsr mon_print_hex             ; print hex representation of byte
	puls B, X                     ; restore B and X
	leax 1,X                      ; advance to next byte
	decb                          ; one less byte to read
	jmp 10b

99
	stx vmonaddr                  ; store updated address

	ldx #CRLF
	jsr acia_send_string

	rts

;; Command handler for 'w' (write) command.
;; Parses hex byte values from the command string and
;; writes them to memory at current monitor address.
;; Current monitor address is incremented by number of
;; byte values succesfully parsed.
mon_w_cmd
	ldy vmonaddr                  ; load monitor address into Y

10
	; check whether either of the next two bytes is the NUL terminator
	lda ,X                        ; check first byte
	beq 99f                       ; if NUL, we're done
	lda 1,X                       ; check second byte
	beq 99f                       ; if NUL, we're done

	; next two bytes aren't NUL, so convert to hex
	pshs Y                        ; save Y
	jsr mon_parse_hex             ; convert two hex digits to int
	puls Y                        ; restore Y
	sta ,Y+                       ; save byte value and increment Y
	jmp 10b

99
	sty vmonaddr                  ; save updated Y back to monitor addr
	rts

;; Command handler for 'd' (Download Intel hex) command.
;; Intel hex records are read until either an EOF record is
;; read, or an invalid record is read.  Only DATA and EOF
;; records are supported.
mon_d_cmd
1
	; Just keep parsing ihex records until an EOF
	; record or an invalid record is encountered
	jsr mon_read_command
	jsr mon_parse_ihex

	; Record was invalid?
	cmpa #IHEX_ERROR
	beq 66f

	; Reached the EOF record?
	cmpa #IHEX_EOF
	beq 80f

	jmp 1B

66
	ldx #INVALID_RECORD
	jsr acia_send_string
	jmp 99f

80
	ldx #UPLOAD_COMPLETE
	jsr acia_send_string

99
	rts

;; Command handler for 'x' (eXecute) command.
;; It just starts executing code at the current monitor address.
mon_x_cmd
	ldy vmonaddr
	jmp ,Y

;; Command handler for 's' (Subroutine) command.
;; It calls a subroutine at the current monitor address.
mon_s_cmd
	ldy vmonaddr
	jsr ,Y
	rts

;; Command handler for 'm' (Mask) command.
;; It sets the interrupt controller mask register to a
;; specified byte value.
mon_m_cmd
	;; Make sure neither of the first to argument bytes are NUL.
	lda ,X                        ; check first byte
	beq 99f                       ; if NUL, we're done
	lda 1,X                       ; check second byte
	beq 99f                       ; if NUL, we're done

	jsr mon_parse_hex             ; parse hex value
	sta vmaskreg                  ; store mask value to vmaskreg variable
	sta PORT_IRQCTRL              ; store mask value to mask register

99
	rts

;; Toggle bit 4 in the condition code register to enable or
;; disable handling of normal (-IRQ) interrupts.
mon_q_cmd
	tfr CC, A                     ; copy condition codes to A
	anda #0b00010000              ; check whether bit 4 is set
	beq 66F

	;; Bit 4 is currently set, meaning that -IRQ is disabled.
	;; Enable it by clearing bit 4.
	andcc #ENABLE_IRQ
	jmp 99F

66
	;; Bit 4 is currently clear, meaning that -IRQ is enabled.
	;; Disable it by setting bit 4.
	orcc #DISABLE_IRQ

99
	rts

;; This is just for fun
mon_k_cmd
	jsr display_cat_picture
	rts

;;------------------------------------------------------------------
;; Delay subroutines
;;------------------------------------------------------------------

;; Delay routine: clobbers A and X.
delay
	lda #0
1
	jsr delay_inner
	deca
	cmpa #$ff
	blo 1B
	rts

;; Inner delay subroutine: clobbers X.
delay_inner
	ldx #0
1
	leax 1,X
	cmpx #$fff
	blo 1B
	rts

;;------------------------------------------------------------------
;; Hardware device routines
;;------------------------------------------------------------------

i82c55a_init
	; For now, set both groups to mode 0, and configure all ports
	; as output.
	lda #(I82C55A_CTRL_MODESET|I82C55A_CTRL_GROUPA_MODE0|I82C55A_CTRL_GROUPA_PORTA_OUT|I82C55A_CTRL_GROUPA_PORTC_UPPER_OUT|I82C55A_CTRL_GROUPB_MODE0|I82C55A_CTRL_GROUPB_PORTB_OUT|I82C55A_CTRL_GROUPB_PORTC_LOWER_OUT)
	sta PORT_I82C55A_CTRL
	rts

i82c54_init
	; Counter 0 generates the rx/tx clock signal for the ACIA.
	lda #(I82C54_CTRL_SEL_CNT0|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_3|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #ACIA_CLKDIV
	sta PORT_I82C54_CNT0
	lda #0
	sta PORT_I82C54_CNT0

	; Counter 1 is used to generate a timer interrupt.
	; We use mode 2 (rate generator), using a count of 0, which
	; is effectively 65536, thus the timer interrupt occurs as
	; infrequently as possible.
	lda #(I82C54_CTRL_SEL_CNT1|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_2|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #0
	sta PORT_I82C54_CNT1
	lda #0
	sta PORT_I82C54_CNT1

	; Counter 2: mode 3, arbitrarily divide by 6
	lda #(I82C54_CTRL_SEL_CNT2|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_3|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #6
	sta PORT_I82C54_CNT2
	lda #0
	sta PORT_I82C54_CNT2

	rts

;; Initialize the ACIA.  Clobbers A.
acia_init
	; reset ACIA
	lda #ACIA_CTRL_RESET
	sta PORT_ACIA_CTRL

	; initialize ACIA
	lda #ACIA_INIT
	sta PORT_ACIA_CTRL

	rts

;; Send the data byte in A.
;; Note: clobbers the B register.
acia_send
	; Busy wait until TRDE bit is set
1
	ldb PORT_ACIA_STATUS
	andb #ACIA_STATUS_TDRE
	beq 1B

	; Write the data byte
	sta PORT_ACIA_SEND
	rts

;; Send a string of characters.
;; Address of (nul-terminated) string is in X.
;; Note: clobbers A and B, and modifies X.
acia_send_string
1
	lda ,X+          ; load next byte and advance pointer
	beq 2F           ; if nul terminator reached, done
	jsr acia_send    ; send the byte
	jmp 1B           ; continue loop
2
	rts

;; Wait to receive a character from the ACIA, returning
;; the result in A.  Note: clobbers B.
acia_recv
	; Busy wait until RDRF is set
1
	ldb PORT_ACIA_STATUS
	andb #ACIA_STATUS_RDRF
	beq 1B

	; Read the data byte
	lda PORT_ACIA_RECV

	rts

;; Poll to receive a character from the ACIA.
;; If a character is not available, B is set to 0.
;; If a character is available, B is set to 1, and A
;; will contain the character read.
acia_poll
	ldb PORT_ACIA_STATUS     ; check ACIA status
	andb #ACIA_STATUS_RDRF   ; byte is ready?
	beq 99f                  ; if not, we're done (B is 0)

	; character is available, read it and set B to 1
	lda PORT_ACIA_RECV       ; read the character
	ldb #1                   ; set B to 1

99
	rts

;;**********************************************************************
;; Interrupt handling
;;**********************************************************************

;; Initialize the interrupt controller.
irqctrl_init
	lda #$FF         ; all IRQs are masked initially
	sta PORT_IRQCTRL ; store initial mask value in mask register
	sta vmaskreg     ; store initial mask value in vmaskreg variable

	;; Set the flip-flops handling the edge-triggered interrupts
	;; (IRQ3 and IRQ6) to a high (non-asserted) output.
	jsr reset_irq3_ff
	jsr reset_irq6_ff

	;; Fill in all entries in virqtab by copying entries
	;; from DEFAULT_IRQ_HANDLER_TABLE
	lda #16          ; table has 8 entries (16 bytes total)
	ldx #virqtab     ; X is the destination address
	ldy #DEFAULT_IRQ_HANDLER_TABLE ; Y is the source address
1
	ldb ,Y+          ; retrieve byte
	stb ,X+          ; store byte
	deca             ; decrease count
	bne 1B           ; if count != 0, continue loop

99
	rts

;; Main interrupt handler, called automatically in response to
;; CPU's ~IRQ input being asserted.  Determines highest-priority
;; IRQ and dispatches to appropriate handler.
irq_dispatch
	lda PORT_IRQCTRL ; read irq priority
	beq 99F          ; if irq priority=0, there is no interrupt
	cmpa #$07        ; sanity check irq priority is in valid range
	bhi 99F          ; if not, done
	lsla             ; multiply irq priority by 2 (addresses are 2 bytes)
	ldx #virqtab     ; get IRQ handler table base address
	ldy A,X          ; load IRQ handler address
	jsr ,Y           ; dispatch to handler
99
	rti              ; return to main program

;; Default IRQ handler for level-triggered interrupts (does nothing)
noop_irq_handler
	rts

;; Reset IRQ3 flip flop.
;; This should be called after handling IRQ3.
reset_irq3_ff
	lda #IRQ3_FF_SET_ASSERT
	sta PORT_I82C55A_CTRL
	lda #IRQ3_FF_SET_DEASSERT
	sta PORT_I82C55A_CTRL
	rts

;; Reset IRQ6 flip flop.
;; This should be called after handling IRQ6.
reset_irq6_ff
	lda #IRQ6_FF_SET_ASSERT
	sta PORT_I82C55A_CTRL
	lda #IRQ6_FF_SET_DEASSERT
	sta PORT_I82C55A_CTRL
	rts

;;**********************************************************************
;; Keyboard routines
;;**********************************************************************

;; Initialize keyboard. No hardware initialize is needed,
;; but variables used by the keyboard routines are initialized.
kbd_init
	lda #0                         ; clear key modifiers
	sta vmodkey                    ; store in vmodkey
	rts

;; Return an ASCII value read from the keyboard.
;; If no key is available, the B register is set to 0.
;; If a key is available, the B register is set to 1, and
;; the A register will contain the character code.
kbd_poll
	ldb #$00                      ; assume no keypress available
	lda PORT_KBCTRL_STATUS        ; read status
	anda #KBD_STATUS_FIFO_NOT_EMPTY ; check not empty flag
	cmpa #$00                     ; FIFO is empty?
	beq 99f                       ; if empty, done

	lda PORT_KBCTRL_DATA          ; read scan code

	; Check whether shift or control were pressed or released
	jsr kbd_check_mod_keys

	tfr A, B                      ; copy scan code to B
	andb #KBD_SCAN_PRESS          ; check whether press

	cmpb #$00                     ; is not press?
	beq kbd_poll                  ; if not press, try to get next scan code

	pshs X                        ; preserve value of X register

	; Unset the press bit
	anda #~KBD_SCAN_PRESS         ; unset the "pressed" bit

	ldb vmodkey                   ; check key modifiers
	andb #KBD_SHIFT_MOD           ; is shift pressed?
	bne 70f                       ; jump to "shift pressed" case if appropriate

	; Shift is not pressed, use keycode_not_shifted table
	ldx #keycode_not_shifted
	jmp 80f

70
	; Shift is pressed, use keycode_shifted table
	ldx #keycode_shifted

80
	lda A,X                       ; translate scan code to character code
	ldb #1                        ; character code is available

	puls X                        ; restore value of X register

99
	rts

;; Check whether the scan code in the A register is a press or a release
;; of a modifier key (shift or control), and if so, update vmodkey.
;; Preserves register values.
kbd_check_mod_keys
	pshs B                        ; save original B value
	tfr A, B                      ; copy scancode to B

	cmpb #KBD_SCAN_SHIFT_PRESS    ; is shift press?
	bne 2f                        ; if not, next case
	ldb vmodkey                   ; get current key mod state
	orb #KBD_SHIFT_MOD            ; set shift mod bit
	stb vmodkey                   ; store in vmodkey
	jmp 99f                       ; done

2
	cmpb #KBD_SCAN_CTRL_PRESS     ; is control press?
	bne 3f                        ; if not, next case
	ldb vmodkey                   ; get current key mod state
	orb #KBD_CTRL_MOD             ; set control mod bit
	stb vmodkey                   ; store in vmodkey
	jmp 99f                       ; done

3
	cmpb #KBD_SCAN_SHIFT_RELEASE  ; is shift release?
	bne 4f                        ; if not, next case
	ldb vmodkey                   ; get current key mode state
	andb #~KBD_SHIFT_MOD          ; clear shift mod bit
	stb vmodkey                   ; store in vmodkey
	jmp 99f                       ; done

4
	cmpb #KBD_SCAN_CTRL_RELEASE   ; is shift release?
	bne 99f                       ; if not, done
	ldb vmodkey                   ; get current key mode state
	andb #~KBD_CTRL_MOD           ; clear control mod bit
	stb vmodkey                   ; store in vmodkey

99
	puls B                        ; restore original B value
	rts

;;;**********************************************************************
;;; TMS9918A VDP routines
;;;**********************************************************************
;
;;; Initialize the VDP.
;;; For now, go into text mode.
;tms9918a_init
;	; Write initial values to VDP register
;
;	lda #TMS9918A_TEXTMODE_R0_INIT
;	ldb #0
;	jsr tms9918a_write_reg
;	jsr delay
;
;	lda #TMS9918A_TEXTMODE_R1_INIT
;	ldb #1
;	jsr tms9918a_write_reg
;	jsr delay
;
;	lda #TMS9918A_TEXTMODE_R2_INIT
;	ldb #2
;	jsr tms9918a_write_reg
;	jsr delay
;
;	lda #TMS9918A_TEXTMODE_R4_INIT
;	ldb #4
;	jsr tms9918a_write_reg
;	jsr delay
;
;	;lda #((TMS9918A_COLOR_WHITE<<4) | TMS9918A_COLOR_BLACK)
;	lda #((TMS9918A_COLOR_WHITE<<4) | TMS9918A_COLOR_DK_BLUE)
;	ldb #7
;	jsr tms9918a_write_reg
;	jsr delay
;
;	; Clear the VRAM
;	jsr tms9918a_clear_vram
;
;	; Load text font into the pattern area (starting at $0000 in VRAM)
;	jsr tms9918a_load_font
;
;	; can we display some text?
;	ldx #$800
;	jsr tms9918a_set_addr
;	ldx #ALL_YOUR_BASE
;	jsr tms9918a_write_str
;
;	rts
;
;;; Write a byte to a TMS9918A register.
;;; A=data byte, B=which register to write
;tms9918a_write_reg
;	sta PORT_TMS9918A_CTRL        ; value to write
;	jsr tms9918a_delay
;	orb #$80                      ; set MSB of byte containing reg num
;	stb PORT_TMS9918A_CTRL        ; write register number
;	jsr tms9918a_delay
;	rts
;
;;; Set 14-bit VRAM to access.
;;; X=address, clobbers A
;tms9918a_set_addr
;	pshs X                        ; push MSB and LSB of VRAM address
;	puls B                        ; pop VRAM addr MSB to B
;	puls A                        ; pop VRAM addr LSB to A
;	sta PORT_TMS9918A_CTRL        ; write LSB of address
;	jsr tms9918a_delay
;	orb #$40                      ; two most significant bits should be 01
;	stb PORT_TMS9918A_CTRL        ; write MSB of address
;	jsr tms9918a_delay
;	rts
;
;;; Clear VRAM
;;; Clobbers X and A
;tms9918a_clear_vram
;	; Set VRAM address to 0
;	ldx #0
;	jsr tms9918a_set_addr
;
;	ldx #16384                    ; X is count of # bytes to write
;1
;	lda #0
;	sta PORT_TMS9918A_DATA        ; write 0 to VRAM
;	jsr tms9918a_delay
;	leax -1,X                     ; decrement X
;	cmpx #0                       ; X is 0?
;	bne 1b                        ; if not, continue loop
;
;	rts
;
;;; Load font data into VRAM.
;;; Clobbers X/A.
;tms9918a_load_font
;	leas -2,S                     ; reserve 2 bytes on stack
;	ldx #$0000                    ; load font data to address $0000 in VRAM
;	jsr tms9918a_set_addr         ; set address
;	ldx #(tms9918a_font+1024)     ; address at end of font data
;	stx ,S                        ; store end address on stack
;	ldx #tms9918a_font            ; get address of font
;1
;	lda ,X+                       ; get next byte of font data, incr pointer
;	sta PORT_TMS9918A_DATA        ; write font byte to VRAM
;	jsr tms9918a_delay
;	cmpx ,S                       ; has pointer reached end of font data?
;	bne 1b                        ; if not, continue loop
;	leas 2,S                      ; clear stack
;	rts
;
;;; Write a NUL-terminated string to VDP memory.
;;; Assumes that the VRAM address has already been set to
;;; the desired destination.
;;; X=ptr to string to write
;;; Clobbers A
;tms9918a_write_str
;1
;	lda ,X+                       ; get next byte from string
;	cmpa #0                       ; is NUL terminator?
;	beq 99f                       ; if so, done copying the string
;	sta PORT_TMS9918A_DATA        ; write byte to VRAM
;	jsr tms9918a_delay            ; delay
;	jmp 1b                        ; continue loop
;99
;	rts
;
;tms9918a_delay
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	nop
;	rts

;;**********************************************************************
;; Hardware VGA 80x30 text display routines
;;**********************************************************************

	INCLUDE "hwvgafns.asm"

;;**********************************************************************
;; A routine to display something fun in the terminal
;;**********************************************************************

display_cat_picture
	ldx #CAT_PICTURE
	jsr acia_send_string
	rts

;;**********************************************************************
;; Constant data
;;**********************************************************************

;; This is printed on startup
ALL_YOUR_BASE FCB "All your base are belong to us",CR,NL,0

HEX_DIGITS FCB "0123456789ABCDEF"

;; CRLF string
CRLF FCB CR,NL,0

;; ROM monitor prompt
MONITOR_PROMPT FCB "> ",0

;; Monitor error message
MONITOR_ERR_MSG FCB "?",CR,NL,0

;; Monitor identification message (printed when '?' command is entered)
MONITOR_IDENT_MSG FCB "6809 ROM monitor, 2019-2023 by daveho hacks",CR,NL,0

;; Monitor command codes.
;; This must be NUL-terminated.
MONITOR_COMMANDS FCB "?earwdxsmqk",0

;; Handler routines for monitor commands.
;; Order should match MONITOR_COMMANDS.
MONITOR_DISPATCH_TABLE
	FDB mon_ques_cmd
	FDB mon_e_cmd
	FDB mon_a_cmd
	FDB mon_r_cmd
	FDB mon_w_cmd
	FDB mon_d_cmd
	FDB mon_x_cmd
	FDB mon_s_cmd
	FDB mon_m_cmd
	FDB mon_q_cmd
	FDB mon_k_cmd

;; Default interrupt handler routines.
;; This table will be copied into virqtab (in RAM) to allow
;; new interrupt handler routines to be installed.
DEFAULT_IRQ_HANDLER_TABLE
	FDB noop_irq_handler          ; not used
	FDB noop_irq_handler          ; IRQ1
	FDB noop_irq_handler          ; IRQ2
	FDB reset_irq3_ff             ; IRQ3 (edge triggered, must reset FF)
	FDB noop_irq_handler          ; IRQ4
	FDB noop_irq_handler          ; IRQ5
	FDB reset_irq6_ff             ; IRQ6 (edge triggered, must reset FF)
	FDB noop_irq_handler          ; IRQ7

INVALID_RECORD FCB "Invalid record",CR,NL,0

UPLOAD_COMPLETE FCB "Upload complete",CR,NL,0

CAT_PICTURE
	FCB CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,95,CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,92,96,42,45,46,CR,NL
	FCB 32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,32,32,32,32,32,32,32,32,41,32,32,95,96,45,46,CR,NL
	FCB 32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,46,32,32,58,32,96,46,32,46,CR,NL
	FCB 32,32,42,32,32,32,32,32,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,58,32,95,32,32,32,39,32,32,92,CR,NL
	FCB 32,32,42,32,32,32,32,32,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,59,32,42,96,32,95,46,32,32,32,96,42,45,46,95,CR,NL
	FCB 32,32,42,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,42,32,32,32,32,42,32,32,32,42,42,42,42,42,32,32,32,32,32,32,32,32,32,32,96,45,46,45,39,32,32,32,32,32,32,32,32,32,32,96,45,46,CR,NL
	FCB 32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,32,32,59,32,32,32,32,32,32,32,96,32,32,32,32,32,32,32,96,46,CR,NL
	FCB 32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,32,32,58,46,32,32,32,32,32,32,32,46,32,32,32,32,32,32,32,32,92,CR,NL
	FCB 32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,42,32,32,32,32,42,32,32,32,32,32,32,32,42,32,32,32,32,32,32,32,32,32,32,32,32,46,32,92,32,32,46,32,32,32,58,32,32,32,46,45,39,32,32,32,46,CR,NL
	FCB 32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,42,42,42,42,32,32,32,32,32,32,32,32,32,32,32,32,32,39,32,32,96,43,46,59,32,32,59,32,32,39,32,32,32,32,32,32,58,CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,58,32,32,39,32,32,124,32,32,32,32,59,32,32,32,32,32,32,32,59,45,46,CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,35,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,59,32,39,32,32,32,58,32,58,96,45,58,32,32,32,32,32,95,46,96,42,32,59,CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,46,42,39,32,47,32,32,46,42,39,32,59,32,46,42,96,45,32,43,39,32,32,96,42,39,CR,NL
	FCB 32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,96,42,45,42,32,32,32,96,42,45,42,32,32,96,42,45,42,39,CR,NL
	FCB 32,32,32,32,35,32,35,35,35,32,32,35,32,32,32,32,35,32,32,32,35,32,32,32,35,35,35,32,32,32,32,35,35,35,CR,NL
	FCB 32,32,32,32,35,35,32,32,32,32,32,35,32,32,32,32,35,32,32,32,35,32,32,35,32,32,32,35,32,32,35,CR,NL
	FCB 32,32,32,32,35,32,32,32,32,32,32,35,32,32,32,32,35,32,32,32,35,32,32,35,35,35,35,35,32,32,32,35,35,35,CR,NL
	FCB 32,32,32,32,35,32,32,32,32,32,32,35,32,32,32,35,35,32,32,32,35,32,32,35,32,32,32,32,32,32,32,32,32,32,35,CR,NL
	FCB 32,32,32,32,35,32,32,32,32,32,32,32,35,35,35,32,35,32,32,32,35,32,32,32,35,35,35,32,32,32,32,35,35,35,CR,NL
	FCB CR,NL
	FCB 0

;;**********************************************************************
;; Scancode to ASCII code translation table: defines
;; keycode_not_shifted and keycode_shifted tables, which map
;; scancodes (without bit 6, the "pressed" bit) to ASCII
;; codes.
;;**********************************************************************

	INCLUDE "kbd_translate.asm"

;;**********************************************************************
;; TMS9918A text font
;;**********************************************************************

	INCLUDE "tms9918a_font.asm"

;;**********************************************************************
;; Table to look up reversals of text attributes.
;; Arguably wastes 256 bytes of ROM, but I'm lazy.
;;**********************************************************************

REVERSE_ATTR
	INCLUDE "revattr.asm"

;;**********************************************************************
;; System address table
;;
;; Programs loaded into RAM can use this table to locate addresses
;; of monitor functions and data.  There is no significance to the
;; order of the entries.  New entries should be added to the end.
;;
;; The include file "offtab.asm" contains symbolic names for the
;; addresses of each entry, and is the preferred way to (indirectly)
;; refer to monitor routines from other programs.
;;**********************************************************************

	ORG $FE00
	FDB reset_irq3_ff
	FDB reset_irq6_ff
	FDB mon_print_hex
	FDB mon_print_hex_d
	FDB acia_send
	FDB acia_send_string
	FDB acia_recv
	FDB delay
	FDB kbd_poll

;;**********************************************************************
;; Interrupt vectors
;;**********************************************************************

	;; IRQ vector
	ORG $FFF8
	FDB irq_dispatch

	;; reset vector
	ORG $FFFE
	FDB entry

;; vim:ft=asm6809:
;; vim:ts=4:
