	INCLUDE "iodev.asm"

;;**********************************************************************
;; Constants
;;**********************************************************************

;; Character values
CR EQU $0D
NL EQU $0A
SPACE EQU $20
TAB EQU $09
COLON EQU $3A

;; 3.6864 MHz crystal: E clock is 921.6 kHz, divide by 96 to get 9600 bps
ACIA_CLKDIV EQU 6

;; Compute initial value for ACIA control register
;; Note that even though the rx/tx clock is generated by
;; the 82C54 counter/timer, the ACIA /16 divisor is used,
;; because with the /1 divisor, there is no automatic
;; synchronization of the rx/tx data and clocks.
ACIA_INIT EQU (ACIA_CTRL_CLKDIV_16 | ACIA_CTRL_SEL_8N1 | ACIA_CTRL_XMIT_RTS_LOW_TX_INT_DIS | ACIA_CTRL_RX_INT_DIS)

;;**********************************************************************
;; Variables
;;**********************************************************************
count_var EQU $1000

;;**********************************************************************
;; Code
;;**********************************************************************

	;; The first 4K of the upper 32K is not used because it
	;; is reserved for I/O devices.
	ORG $8000
	FILL $FF, 4096

	;; The actual code begins at $9000
	ORG $9000

entry
	;; put system stack at top of RAM
	lds #$7FFE

	;; Initialize the i82c55a device
	jsr i82c55a_init

	;; Initialize the i82c54 device
	jsr i82c54_init

;	;; Initialize the ACIA
;	jsr acia_init
;
;	;; ACIA test: transmit a message
;	ldx #ALL_YOUR_BASE
;	jsr acia_send_string

	;; clear count variable
	lda #0
	sta count_var

main_loop
	lda count_var                 ; load count variable
	sta PORT_I82C55A_A            ; store to i82c55a port A register

	inca                          ; increment count
	sta count_var                 ; store updated value to count

	jsr delay                     ; delay
	jmp main_loop                 ; repeat main loop

;; Delay routine: clobbers A and X.
delay
	lda #0
1
	jsr delay_inner
	deca
	cmpa #$ff
	blo 1B
	rts

;; Inner delay subroutine: clobbers X.
delay_inner
	ldx #0
1
	leax 1, x
	cmpx #$fff
	blo 1B
	rts

i82c55a_init
	; For now, set both groups to mode 0, and configure all ports
	; as output.
	lda #(I82C55A_CTRL_MODESET|I82C55A_CTRL_GROUPA_MODE0|I82C55A_CTRL_GROUPA_PORTA_OUT|I82C55A_CTRL_GROUPA_PORTC_UPPER_OUT|I82C55A_CTRL_GROUPB_MODE0|I82C55A_CTRL_GROUPB_PORTB_OUT|I82C55A_CTRL_GROUPB_PORTC_LOWER_OUT)
	sta PORT_I82C55A_CTRL
	rts

i82c54_init
	; Counter 0 generates the rx/tx clock signal for the ACIA.
	lda #(I82C54_CTRL_SEL_CNT0|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_3|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #ACIA_CLKDIV
	sta PORT_I82C54_CNT0
	lda #0
	sta PORT_I82C54_CNT0

	; Counter 1 is used to generate a timer interrupt.
	; We use mode 2 (rate generator), using a count of 0, which
	; is effectively 65536, thus the timer interrupt occurs as
	; infrequently as possible.
	lda #(I82C54_CTRL_SEL_CNT1|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_2|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #0
	sta PORT_I82C54_CNT1
	lda #0
	sta PORT_I82C54_CNT1

	; Counter 2: mode 3, arbitrarily divide by 6
	lda #(I82C54_CTRL_SEL_CNT2|I82C54_CTRL_RW_LSB_MSB|I82C54_CTRL_MODE_3|I82C54_CTRL_BCD_DIS)
	sta PORT_I82C54_CTRL
	lda #6
	sta PORT_I82C54_CNT2
	lda #0
	sta PORT_I82C54_CNT2

	rts

;; Initialize the ACIA.  Clobbers A.
acia_init
	; reset ACIA
	lda #ACIA_CTRL_RESET
	sta PORT_ACIA_CTRL

	; initialize ACIA
	lda #ACIA_INIT
	sta PORT_ACIA_CTRL

	rts

;; Send the data byte in A.
;; Note: clobbers the B register.
acia_send
	; Busy wait until TRDE bit is set
1
	ldb PORT_ACIA_STATUS
	andb #ACIA_STATUS_TDRE
	beq 1B

	; Write the data byte
	sta PORT_ACIA_SEND
	rts

;; Send a string of characters.
;; Address of (nul-terminated) string is in X.
;; Note: clobbers A and B, and modifies X.
acia_send_string
1
	lda ,X+          ; load next byte and advance pointer
	beq 2F           ; if nul terminator reached, done
	jsr acia_send    ; send the byte
	jmp 1B           ; continue loop
2
	rts

;; Wait to receive a character, returning
;; the result in A.  Note: clobbers B.
acia_recv
	; Busy wait until RDRF is set
1
	ldb PORT_ACIA_STATUS
	andb #ACIA_STATUS_RDRF
	beq 1B

	; Read the data byte
	lda PORT_ACIA_RECV

	rts

;;**********************************************************************
;; Constant data
;;**********************************************************************

ALL_YOUR_BASE FCB "All your base are belong to us",CR,NL,0

;;**********************************************************************
;; Interrupt vectors
;;**********************************************************************

	;; reset vector
	ORG $FFFE
	FDB entry

;; vim:ft=asm6809:
;; vim:ts=4:
